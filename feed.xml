<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://he-zh.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://he-zh.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-06-05T20:57:36+00:00</updated><id>https://he-zh.github.io/feed.xml</id><title type="html">blank</title><subtitle>Academic website of Zheng HE. </subtitle><entry><title type="html">a note on learning bounds</title><link href="https://he-zh.github.io/blog/2023/learning-bounds-note/" rel="alternate" type="text/html" title="a note on learning bounds"/><published>2023-12-30T00:00:00+00:00</published><updated>2023-12-30T00:00:00+00:00</updated><id>https://he-zh.github.io/blog/2023/learning-bounds-note</id><content type="html" xml:base="https://he-zh.github.io/blog/2023/learning-bounds-note/"><![CDATA[<h1 id="overview">Overview</h1> <p>In the heart of machine learning lies a fundamental question: <strong>can we trust the predictions of our models beyond the data we trained them on?</strong> This is where the analysis of generalization error comes into play.</p> <p>Central to this analysis lies the concept of excess error, a measure of how much a model’s performance deviates from its ideal, true performance. But this excess error isn’t a monolithic entity; it’s a captivating dance between two key players: approximation error and estimation error.</p> \[\underbrace{L_D(\hat h_S) - L_{Bayes}}_\text{excess error} = \underbrace{L_D(\hat h_S) - L_D(h^*)}_\text{estimation error} + \underbrace{L_D(h^*) - L_{Bayes}}_\text{approximation error},\] <p>where \(\hat h_S \in \arg\min_{h\in\mathcal{H}} L_S(h)\), \(h^* = \arg\inf_{h\in\mathcal{H}} L_D(h)\), \(L_S(\cdot)\) is the empirical risk and \(L_D(\cdot)\) is the expected risk.</p> <ul> <li><strong>Excess Error:</strong> \(L_D(\hat h_S) - L_{Bayes}\) is the difference between the error of a model and the Bayes error (Bayes risk or irreducible error) on a given task.</li> <li><strong>Bayes Error:</strong> \(L_{Bayes}\) represents the lowest achievable error rate for any classifier on that task.</li> <li>The excess error in Empirical Risk Minimization (ERM) can be effectively bounded by dissecting it into two primary components: estimation error and approximation error.</li> <li><strong>Estimation Error:</strong> \(L_D(\hat h_S) - L_D(h^*)\) arises from using our algorithm \(\hat h_S\) instead of selecting the best predictor \(h^*\) within the hypothesis space \(\mathcal{H}\). As the sample size m approaches infinity, the estimation error ideally tends toward zero.</li> <li><strong>Approximation Error:</strong> \(L_D(h^*) - L_{Bayes}\) is incurred by choosing the optimal predictor within \(\mathcal{H}\) rather than utilizing the optimal classifier (Bayes classifier) from any hypothesis.</li> </ul> <p>This note delves into various techniques that offer guarantees on how well our models generalize based on uniform or non-uniform convergence, and introduce concepts like VC dimension, covering numbers, Rademacher complexity and stability bound.</p> <h1 id="uniform-convergence">Uniform convergence</h1> <p>Bounding the estimation error of Empirical Risk Minimization (ERM) involves controlling the generalization gap between the empirical risk and the expected risk. The estimation error could be written as</p> \[L_D(\hat h_S) - L_D(h^*) \le L_D(\hat h_S) - L_S(\hat h_S) + L_S(h^*) - L_D(h^*)\] <p>and we can probabilistically bound Generalization gap for \(h^*\) and \(\hat h_S\).</p> <p><strong>Upper bound \(L_S(h^*) - L_D(h^*)\):</strong> Hoeffiding’s inequality</p> <p>Let \(L_S(h^*)\) be an average of iid random variables and \(L_D(h^*)\) be its expectation, we have</p> \[L_S(h^*) - L_D(h^*) = \frac{1}{m}\sum_{i=1}^{m} \ell(h,z_i) - \mathbb{E}_{z\sim D} \ell (h,z),\] <p>If we further assume that \(\ell(h,z)\in [a, b]\) for all \(h, z\), we could apply <a href="https://en.wikipedia.org/wiki/Hoeffding%27s_inequality">Hoeffding’s inequality</a> to get</p> \[\mathrm{Pr}(L_S(h^*) - L_D(h^*) \le (b-a) \sqrt{\frac{\log 1/\delta}{2m}} ) \ge 1-\delta\] <ul> <li>For the assumption that \(\ell(h,z)\in [a, b]\) <ul> <li>bounded loss naturally satisfies <ul> <li>0-1 loss, ramp loss</li> </ul> </li> <li>unbounded loss might be depending on \(H\) and \(D\) <ul> <li>square loss, logistic loss, hinge loss…</li> </ul> </li> </ul> </li> </ul> <p><strong>Upper bound \(L_D(\hat h_S) - L_S(\hat h_S)\):</strong> uniform convergence</p> <p>We can’t apply <a href="https://en.wikipedia.org/wiki/Hoeffding%27s_inequality">Hoeffding’s inequality</a> directly on the generalization gap of \(\hat h_S\) as \(\ell(\hat h_S, z_i)\) aren’t independent. The choice of \(\hat h_S\) depends on all of \(S\), i.e. on all of the other \(z_j\) , as well as the ones we’re evaluating on.</p> <p><strong>Uniform convergence.</strong> The basic idea is that if we know that \(L_D(h) - L_S(h)\) is small for all \(h\in\mathcal{H}\), then it’ll be small for \(\hat h_S\)</p> \[L_D(\hat h_S) - L_S(\hat h_S) \le \sup_{h\in\mathcal{H}} L_D(h) - L_S(h) ,\] <p>and bound the \(\sup_{h\in\mathcal{H}} L_D(h) - L_S(h)\) instead.</p> <p>Here are a few commonly used techniques:</p> <ul> <li>Finite \(\vert \mathcal{H}\vert &lt;\infty\) <ul> <li>we could use the union bound <ul> <li>but \(\vert \mathcal{H}\vert\) might be really large which makes the bound vacuous</li> </ul> </li> </ul> </li> <li>Infinite \(\vert \mathcal{H}\vert =\infty\) <ul> <li>covering numbers</li> <li>Rademacher complexity</li> <li>VC dimension</li> </ul> </li> </ul> <hr/> <h2 id="finite-hypothesis-class-mathcalhinfty">Finite hypothesis class \(|\mathcal{H}|&lt;\infty\)</h2> <p>With probability at least \(1-\delta\), we have</p> \[\begin{align*}L_D(\hat h_S) - L_D(h^*) &amp;\le \sup_{h\in\mathcal{H}}[ L_D(h) - L_S(h)] + L_S(h^*) - L_D(h^*) \\ &amp;\le (b-a) \sqrt{\frac{2}{m}\log \frac{|H|+1}{\delta}} \end{align*}\] <details><summary>Proof for the finite hypothesis class bound</summary> <p>We start by noting</p> \[\sup_{h\in\mathcal{H}} L_D(h) - L_S(h) \le \varepsilon \leftrightarrow \forall h\in\mathcal{H}. \ L_D(h) - L_S(h) \le \varepsilon\] <p>Use union bound \(P(A+B) \le P(A) + P(B)\) we get</p> \[\mathrm{Pr}_{S\sim D^m}(\exists h\in\mathcal{H}. \ L_S(h) - L_D(h) &gt; \varepsilon) \le \sum_{h\in\mathcal{H}} P_{S\sim D^m} (L_S(h) - L_D(h) &gt; \varepsilon)\] <p>Let \(\mathrm{Pr}_{S\sim D^m} (L_S(h) - L_D(h) &gt; \varepsilon) \le \frac{\delta}{|H|+1}\) for \(\forall h \in\mathcal{H}\), where \(\varepsilon=(b-a) \sqrt{\frac{1}\log \frac{|H|+1}{\delta}}\) then</p> \[\begin{align*} \mathrm{Pr}_{S\sim D^m}(\exists h\in\mathcal{H}. \ L_S(h) - L_D(h) &gt; \varepsilon) \le \frac{|\mathcal{H}|\delta}{|\mathcal{H}|+1}\\ \mathrm{Pr}_{S\sim D^m}(L_S(h^*) - L_D(h^*) &gt; \varepsilon) \le \frac{\delta}{|\mathcal{H}|+1}\end{align*}\] <p>Thus, we have</p> \[\mathrm{Pr}_{S\sim D^m}\left((\sup_{h\in\mathcal{H}} L_S(h) - L_D(h) \le \varepsilon) \bigcap (L_S(h^*) - L_D(h^*) \le \varepsilon)\right) \ge 1- \delta,\] <p>which means with probability at least \(1-\delta\), the following inequality holds</p> \[\sup_{h\in\mathcal{H}}[ L_S(h) - L_D(h)] + L_S(h^*) - L_D(h^*) \le 2\varepsilon\] </details> <p><br/></p> <hr/> <h2 id="infinite-hypothesis-class-mathcalhinfty">Infinite hypothesis class \(|\mathcal{H}|=\infty\)</h2> <h3 id="covering-numbers">Covering numbers</h3> <p>We can rewrite the uniform bound like this</p> \[\begin{align*} &amp;\sup_{h\in\mathcal{H}} L_D(h) - L_S(h) \\ &amp;= \sup_{h\in\mathcal{H}} L_D(h) - L_D(t) + L_D(t) - L_S(t) + L_S(t)- L_S(h) \\ &amp;\le \sup_{h\in\mathcal{H}} [L_D(h) - L_D(t)] + \sup_{t\in\mathcal{T}} [L_D(t) - L_D(t)] + \sup_{h\in\mathcal{H}} [L_S(t)- L_S(h)] \end{align*}\] <p>where \(\mathcal{T}\) is a finite \(ρ\)-cover set of \(\mathcal{H}\).</p> <p><strong>Definition (\(\rho\)-cover set).</strong> A \(ρ\)-cover of a set \(\mathcal{H}\) is a set \(\mathcal{T}⊆\mathcal{H}\) such that, for all \(h∈\mathcal{H}\), there is a \(t ∈ \mathcal{T}\) with \(dist(t, h) ≤ ρ\). The smallest size of the \(\rho\)-cover set of \(\mathcal{H}\) is \(N(\mathcal{H}, \rho)\).</p> <p><strong>Bounds with \(\rho\)-covering</strong></p> <ul> <li>To bound the first and the third term, we need to assume <a href="https://en.wikipedia.org/wiki/Lipschitz_continuity">Lipschitz continuity</a> of loss that \(\vert \ell(h,z) - \ell(t,z)\vert \le K \Vert {h(x)-t(x)}\Vert\). According to the assumption of \(ρ\)-cover, we also have \(\Vert{h-t}\Vert \le \rho\). Thus, we can bound the differences respectively.</li> <li>To bound the second term, as \(\mathcal{T}\) is finite set, we could apply <a href="https://en.wikipedia.org/wiki/Hoeffding%27s_inequality">Hoeffding’s inequality</a> as the finite hypothesis class case. The only problem is how to decide the size of \(\mathcal{T}\).</li> </ul> <details><summary><strong>Example:</strong> logistic regression with bounded \(X\) and bounded \(\mathcal{H}\)</summary> <ul> <li>Input space \(Z = X \times Y, X = \mathbb{R}^d, \Vert x\Vert \le C, Y=\{-1,1\}\)</li> <li>Hypothesis class \(\mathcal{H}=\{x\to w\cdot x : w\in \mathbb{R}^d, \Vert w\Vert \le B\}\)</li> <li>Logistic loss \(\ell_{\rm{log}} (h,z) =l_y(h(x)) = \log(1+\exp(-y h(x)))\), which is 1-Lipschitz. And we also have \(\vert \ell_{\rm{log}} (h,z)\vert \le |1+h(x)\vert \le 1+BC\) According to Lipschitz continuity, we have \(\vert \ell(h,z) - \ell(t,z)\vert \le \Vert{w\cdot x - t\cdot x}\Vert \le \Vert w-t\Vert \Vert x\Vert = \rho C\). Thus,</li> </ul> \[\begin{align*} \sup_{h\in\mathcal{H}} [L_D(h) - L_D(t)] \le \rho C \\ \sup_{h\in\mathcal{H}} [L_S(h) - L_S(t)] \le \rho C \end{align*}\] <p>Besides, with probability at least \(1-\delta\), we have</p> \[\sup_{h\in\mathcal{T}} L_D(t) - L_S(t) \le (1+BC) \sqrt{\frac{1}{2m}\log\frac{N(\mathcal{H},\rho)}{\delta}} \le \frac{1+BC}{\sqrt{2m}} \left(\sqrt{\log\frac{1}{\delta}} + \sqrt{\log N(\mathcal{H},\rho)}\right)\] <p><strong>The overall bound on estimation error of logistic regression:</strong> from the above, we know that</p> \[\begin{align*} &amp;\mathrm{Pr}\left(\sup_{h\in\mathcal{H}} [L_D(h) - L_S(h)] &gt; 2\rho C + \frac{1+BC}{\sqrt{2m}} (\sqrt{\log\frac{1}{\delta}} + \sqrt{\log N(\mathcal{H},\rho)}) \right) &lt; \delta \\ &amp;\mathrm{Pr}\left(L_S(h^*) - L_D(h^*) &gt; \frac{1+BC}{\sqrt{2m}} \sqrt{\log\frac{1}{\delta}} \right) &lt; \delta \end{align*}\] <p>Thus, with probability at least \(1-\delta\) the following holds</p> \[\begin{align*} L_D(\hat h_S) - L_D(h^*) &amp;\le \sup_{h\in\mathcal{H}} [L_D(h) - L_S(h)] + L_S(h^*) - L_D(h^*)\\ &amp;\le 2\rho C + \frac{1+BC}{\sqrt{2m}} (2\sqrt{\log\frac{2}{\delta}} + \sqrt{\log N(\mathcal{H},\rho)}) \end{align*}\] <p>where \(\rho\) can be further optimized to get rid of \(\rho\) and obtain a tighter bound.</p> </details> <p><br/></p> <hr/> <h3 id="rademacher-complexity">Rademacher complexity</h3> <ul> <li>Rademacher complexity is typically applied on a function class of models that are used for <strong>classification</strong>, with the goal of measuring their ability to classify points drawn from a probability space under arbitrary labellings.</li> <li>When the function class is rich enough, it contains functions that can appropriately adapt for each arrangement of labels, simulated by the random draw of \(\sigma_i\) under the expectation, so that this quantity in the sum is maximized.</li> <li>measures richness of a class of real-valued functions with respect to a probability distribution.</li> </ul> <p><strong>Definition (Rademacher complexity).</strong> The Rademacher complexity of a set \(V ⊆ \mathbb{R}^m\) is given by \(\mathrm{Rad}(V) = \mathbb{E}_{\sigma\sim\rm{Unif}(\pm1)^m} \sup_{v\in V} \frac{\sigma \cdot v}{m}\)</p> <p><strong>Relation between the mean worst-case generalization gap and Rademacher complexity</strong></p> \[\mathbb{E}_{S\sim D^m} \sup_{h\in\mathcal{H}} L_D(h) - L_S(h) = 2 \mathbb{E}_{S\sim D^m} \mathrm{Rad}((\ell \circ \mathcal{H})\vert_S)\] <p>where \((\ell \circ \mathcal{H})\vert_S = \{(\ell(h,z_1), \dots, \ell(h,z_m)): h\in \mathcal{H}\}\)</p> <details><summary>Proof for the equation</summary> \[\begin{align*}\mathbb{E}_{S\sim D^m} \sup_{h\in\mathcal{H}} L_D(h) - L_S(h) &amp;=\mathbb{E}_{S\sim D^m} \sup_{h\in\mathcal{H}} [\mathbb{E}_{S'\sim D^m}[L_{S'}(h)] - L_S(h)]\\ &amp;\le \mathbb{E}_{S,S'\sim D^m} \sup_{h\in\mathcal{H}} [L_{S'}(h) - L_S(h)] \\ &amp;= \mathbb{E}_{S,S'\sim D^m} \sup_{h\in\mathcal{H}} \frac 1m \sum_{i=1}^m [\ell(h, z_i) - \ell(h, z_i')]\end{align*}\] <p>Let \(\sigma_i \in [-1,1]\) for \(i \in [m]\), \(P(\sigma_i=1)= P(\sigma_i=-1)= \frac12\), and \(\vec \sigma = (\sigma_1, \dots, \sigma_m)\). Let \((u_i, u_i')=\begin{cases}(z_i, z_i'), &amp;\text{if } \sigma_i=1 \\ (z_i', z_i), &amp;\text{if } \sigma_i=-1 \end{cases}\). So, for any value of \(S, S',\) and \(\vec \sigma\), defining \(U=(u_1, \dots, u_m)\) and \(U'=(u_1', \dots, u_m')\) accordingly, we have \(\ell(h, z_i) - \ell(h, z_i')=\sigma_i (\ell(h, u_i) - \ell(h, u_i'))\). Thus,</p> \[\begin{align*} \mathbb{E}_{S,S} \sup_{h\in\mathcal{H}} \frac 1m \sum_{i=1}^m [\ell(h, z_i) - \ell(h, z_i')] &amp;=\mathbb{E}_{S, S'} \mathbb{E}_{\vec \sigma} \mathbb{E}_{U,U'} [\sup_{h\in\mathcal{H}}\frac{1}{m} \sum_{i=1}^m \sigma_i (\ell(h, u_i) - \ell(h, u_i')) \vert S,S',\vec \sigma]\\ &amp;=\mathbb{E}_{U, U'} \mathbb{E}_{\vec \sigma} \mathbb{E}_{S,S'} [\sup_{h\in\mathcal{H}}\frac{1}{m} \sum_{i=1}^m \sigma_i (\ell(h, u_i) - \ell(h, u_i')) \vert U,U',\vec \sigma]\\ &amp;=\mathbb{E}_{U, U'} \mathbb{E}_{\vec \sigma}[\sup_{h\in\mathcal{H}}\frac{1}{m} \sum_{i=1}^m \sigma_i (\ell(h, u_i) - \ell(h, u_i'))]\\ &amp;=\mathbb{E}_{S, S'} \mathbb{E}_{\vec \sigma}[\sup_{h\in\mathcal{H}}\frac{1}{m} \sum_{i=1}^m \sigma_i (\ell(h, z_i) - \ell(h, z_i'))]\\ &amp;\le \mathbb{E}_{S} \mathbb{E}_{\vec \sigma} \sup_{h\in\mathcal{H}}\frac{1}{m} \sum_{i=1}^m \sigma_i \ell(h, z_i)+\mathbb{E}_{S'} \mathbb{E}_{\vec \sigma} \sup_{h\in\mathcal{H}}\frac{1}{m} \sum_{i=1}^m -\sigma_i \ell(h, z_i')\\ &amp;= 2 \mathbb{E}_{S} \mathbb{E}_{\vec \sigma} \sup_{h\in\mathcal{H}}\frac{1}{m} \sum_{i=1}^m \sigma_i \ell(h, z_i)\\ &amp;= 2 \mathbb{E}_{S\sim D^m} \mathrm{Rad}((\ell \circ \mathcal{H})|_S) \end{align*}\] </details> <p><br/></p> <p><strong>Compute \(\rm{Rad}((\ell \circ \mathcal{H})\vert_S)\)</strong></p> <p><strong>Talagrand’s contraction lemma.</strong> Let \(\phi : \mathbb{R}^m → \mathbb{R}^m\) be given by \(\phi(t) = (φ_1(t_1), \dots, φ_m(t_m))\), where each \(φ_i\) is \(ρ\)-Lipschitz (<a href="https://en.wikipedia.org/wiki/Lipschitz_continuity">Lipschitz continuity</a>). Then</p> \[\mathrm{Rad}(\phi \circ V) = \mathrm{Rad}(\{\phi(v): v\in V\}) \le \rho \mathrm{Rad}(V)\] <p>Thus, if $\ell$ is \(ρ\)-Lipschitz, we have</p> \[\rm{Rad}((\ell \circ \mathcal{H})\vert_S) \le \rho \rm{Rad}(\mathcal{H}\vert_S)\] <details><summary><strong>Example:</strong> logistic regression with bounded \(\mathcal{H}\)</summary> <ul> <li>Input space \(Z = X \times Y, X = \mathbb{R}^d, Y=\{-1,1\}\)</li> <li>Hypothesis class \(\mathcal{H}=\{x\to w\cdot x : w\in \mathbb{R}^d, \Vert w\Vert \le B\}\)</li> <li>Logistic loss \(\ell_{\rm{log}} (h,z) =l_y(h(x)) = \log(1+\exp(-y h(x)))\), which is 1-Lipschitz</li> </ul> \[\begin{align*} \mathrm{Rad} ((l_y\circ \mathcal{H})\vert_S) &amp;\le \mathrm{Rad} (\mathcal{H}|_S)\\ &amp;= \mathbb{E}_\sigma \sup_{\Vert w\Vert \le B} \frac{1}{m} \sum_{i=1}^m \sigma_i \left\langle w, x_i\right\rangle \\ &amp;= \frac{1}{m} \mathbb{E}_\sigma \sup_{\Vert w\Vert \le B} \left\langle w, \sum_{i=1}^m \sigma_i x_i\right\rangle \\ &amp;\le \frac{B}{m} \mathbb{E}_\sigma \Vert \sum_{i=1}^m \sigma_i x_i\Vert \\ &amp;\le \frac{B}{m} \sqrt{\mathbb{E}_\sigma \Vert \sum_{i=1}^m \sigma_i x_i\Vert^2} \\ &amp;= \frac{B}{m} \sqrt{\mathbb{E}_\sigma \sum_{i,j} \left\langle \sigma_i x_i, \sigma_j x_j \right\rangle }\\ &amp;= \frac{B}{m} \sqrt{\mathbb{E}_\sigma \sum_{i} \Vert x_i\Vert^2 + \sum_{i\neq j} \mathbb{E}_\sigma \sigma_i \sigma_j \left\langle x_i, x_j \right\rangle }\\ &amp;= \frac{B}{m} \sqrt{\sum_{i=1}^m \Vert x_i\Vert^2} \end{align*}\] \[\mathbb{E}_S \mathrm{Rad} ((l_y\circ \mathcal{H})\vert_S) \le \frac{B }{\sqrt{m}} \mathbb{E}_S \sqrt{\frac{1}{m} \sum_{i=1}^m \Vert x_i\Vert^2} \le \frac{B }{\sqrt{m}} \sqrt{\mathbb{E}_x \Vert x\Vert^2}\] </details> <p><br/></p> <details><summary><strong>Special case:</strong> 0-1 loss of binary classification</summary> <ul> <li>Input space \(Z = X \times Y, X = \mathbb{R}^d, Y=\{-1,1\}\)</li> <li>Hypothesis class \(\mathcal{H}=\{x\to h(x) : h(x)\in \{-1, 1\}\}\)</li> <li>0-1 loss \(\ell_{\rm{0-1}} (h,z) =l_y(h(x)) = \mathbb{1}_{h(x)\neq y}\) <ul> <li>0-1 loss is not a function on \(\mathbb{R}\), so applying Talagrand’s lemma is a little weird. For computing the loss, we can just extend the function \(l_y\) to \(\mathbb{R}\) in any way at all, and the loss will be exactly the same.</li> <li>So we could pick a \(\frac12-\)Lipschitz function. According to Talagrand’s lemma, we have \(\mathrm{Rad}(\ell_{0-1} \circ \mathcal{H}_{\pm1}) \le \frac12 \mathrm{Rad}(\mathcal{H}_{\pm1})\)</li> </ul> </li> </ul> <p>\(\mathcal{H}\vert_S \subseteq \{-1,1\}^m\) is finite, so we could bound the Rademacher complexity of this finite set based on its size. We have</p> \[\mathrm{Rad}(\mathcal{H}_{\pm1}\vert_S) \le \sqrt{\frac{2}{m} \log \vert\mathcal{H}_{\pm1}\vert_S\vert}\] <blockquote> <p>Growth function \eqref{eq:growth-function} provides the bound of \(\vert \mathcal{H}_{\pm1}\vert_S\vert\).</p> </blockquote> <p><em>Extension: for binary classifiers to {0, 1}, \(\mathrm{Rad}(\mathcal{H}_{0,1}\vert_S)=\mathrm{Rad}(\frac12 (\mathcal{H}_{\pm1} + 1)\vert_S)=\frac12\mathrm{Rad}(\mathcal{H}_{\pm1}\vert_S)\).</em></p> <p>We prove this by utilizing the following lemma and properties of sub-Gaussian distribution. <strong>Rademacher complexity of an arbitrary finite set.</strong> If \(V=\{v: v\in\mathbb{R}^m\}\) is finite, \(\Vert v\Vert \le B\) for all \(v \in V\), then</p> \[\mathrm{Rad} (V)\le \frac{B}{m} \sqrt{2\log \vert V\vert}\] <p><em>Proof.</em> We have \(\mathrm{Rad}(V) = \mathbb{E}_{\sigma\sim\rm{Unif}(\pm1)^m} \sup_{v\in V} \sum_{i=1}^m \frac{\sigma_i v_i}{m}\). According to [[Sub-Gaussian distribution#Sum]], \(\sigma_i \in SG(\frac{1-(-1)}{2})=SG(1)\) and \(\frac{\sigma_i v_i}{m} \in SG(|v_i|/m)\). As each \(v_i\sigma_i\) is independent of each other, we have \(\sum_{i=1}^m \frac{\sigma_i v_i}{m} \in SG(\sqrt{\sum_i v_i^2} /m)=SG(\frac{\Vert v\Vert }{m}) \subseteq SG(\frac{B}{m})\). According to <a href="https://en.wikipedia.org/wiki/Sub-Gaussian_distribution"> Sub-Gaussian distribution </a>, \(\sum_{i=1}^m \frac{\sigma_i v_i}{m}\) is zero-mean random variables that satisfy</p> \[\mathbb{E}_\sigma \left[ \sup_{v_i\in V} \sum_{i=1}^m \frac{\sigma_i v_i}{m} \right] \le \frac{B}{m} \sqrt{2 \log(\vert V\vert)}.\] <p>Thus, \(\mathrm{Rad}(\mathcal{H}_{\pm1}\vert_S) \le \sqrt{\frac{2}{m} \log \vert\mathcal{H}_{\pm1}\vert_S\vert}\)</p> </details> <p><br/></p> <p><strong>High probability bounds with Rademacher complexity</strong> – McDiarmid’s inequality</p> <p>We need to convert the average-case bound into a high probability bound using a concentration inequality - <a href="https://en.wikipedia.org/wiki/McDiarmid%27s_inequality">McDiarmid’s inequality</a>, which is a generalized version of <a href="https://en.wikipedia.org/wiki/Hoeffding%27s_inequality">Hoeffding’s inequality</a>. It could be used to bound the deviation between the sampled value and the expected value of certain functions (i.e., \(\sup_h [L_D(h)-L_S(h)]\)) when they are evaluated on independent random variables.</p> <p><strong>McDiarmid’s inequality for the worst-case generalization gap.</strong> Assume loss is bounded that \(\ell(h,z) \in [a,b]\) for all \(h\) and \(z\). Let \(S=(z_1,\dots,z_i, \dots z_m)\) and \(S^{(i)}=(z_1, \dots, z_i', \dots, z_m)\). Then,</p> \[\begin{align*} \sup_{h\in\mathcal{H}} L_D(h)-L_S(h) &amp;= \sup_{h\in\mathcal{H}}L_D(h) - L_{S^{(i)}}(h) + L_{S^{(i)}}(h) - L_S(h) \\ &amp;\le \sup_{h\in\mathcal{H}} L_D(h) - L_{S^{(i)}}(h) + \sup_{h\in\mathcal{H}}L_{S^{(i)}}(h) - L_S(h) \\ &amp;\le \sup_{h\in\mathcal{H}} L_D(h) - L_{S^{(i)}}(h) + \frac{1}{m}(b-a) \end{align*}\] <p>We could substitute \(S\) and \(S^{(i)}\) without affecting the result, then the absolute value of difference is also bounded that \(\vert \sup_{h\in\mathcal{H}} [L_D(h)-L_S(h)] - \sup_{h\in\mathcal{H}} [L_D(h) - L_{S^{(i)}}(h)]\vert \le \frac{1}{m}(b-a)\). Given the bounded differences property, we could apply McDiarmid’s inequality directly. Thus, with probability at least \(1-\delta\), we have</p> \[\begin{align*}\sup_{h\in\mathcal{H}} L_D(h)-L_S(h) &amp;\le \mathbb{E}_{S\sim D^m} \sup_{h\in\mathcal{H}} L_D(h)-L_{S}(h) + (b-a)\sqrt{\frac{1}{2m}\log\frac{1}{\delta}}\\ &amp;\le 2 \mathbb{E}_{S\sim D^m} \mathrm{Rad}((\ell \circ\mathcal{H})\vert_S) + (b-a)\sqrt{\frac{1}{2m}\log\frac{1}{\delta}} \end{align*}\] <p><strong>The overall bound on estimation error</strong></p> \[\begin{align*} &amp;\mathrm{Pr}\left(\sup_{h\in\mathcal{H}} [L_D(h) - L_S(h)] &gt; 2 \mathbb{E}_{S\sim D^m} \mathrm{Rad}((\ell \circ\mathcal{H})\vert_S) + (b-a)\sqrt{\frac{1}{2m}\log\frac{1}{\delta}} \right) &lt; \delta \\ &amp;\mathrm{Pr}\left(L_S(h^*) - L_D(h^*) &gt; (b-a) \sqrt{\frac{1}{2m}\log\frac{1}{\delta}} \right) &lt; \delta \end{align*}\] <p>With probability at least \(1-\delta\), the estimation error satisfy</p> \[\begin{align*} L_D(\hat h_S) - L_D(h^*) &amp;\le \sup_{h\in\mathcal{H}} [L_D(h)-L_S(h)] + L_S(h^*) - L_D(h^*) \\ &amp;\le 2 \mathbb{E}_{S\sim D^m} \mathrm{Rad}((\ell \circ\mathcal{H})|_S) + (b-a)\sqrt{\frac{2}{m}\log\frac{2}{\delta}} \end{align*}\] <hr/> <h3 id="vc-dimension">VC dimension</h3> <ul> <li>VC dimension is a measure of the size of a class of sets. The notion can be extended to classes of <strong>binary</strong> functions.</li> <li>It is defined as the cardinality of the largest set of points that the algorithm can shatter, which means the algorithm can always learn a perfect classifier for any labeling of at least one configuration of those data points.</li> </ul> <p>The binary classification case in Rademacher complexity section have shown that for hypothesis \(\mathcal{H}_{\pm1}=\{x\to h(x) : h(x)\in \{-1, 1\}\}\), we have \(\mathrm{Rad}(\mathcal{H}_{\pm1}\vert_S) \le \sqrt{\frac{2}{m} \log \vert\mathcal{H}_{\pm1}\vert_S\vert}\). If we use zero-one loss, then \(\mathrm{Rad}(\ell_{0-1} \circ \mathcal{H}_{\pm1}) \le \frac12 \mathrm{Rad}(\mathcal{H}_{\pm1})\). However, \(\mathrm{Rad}(\mathcal{H}_{\pm1}\vert_S)\) depends on particular distribution \(S\), which is not straightforward when taking expectation on it. So we need to upper bound it a little bit to make it look nicer <em>(not \(\vert \mathcal{H}\vert_S\vert \le \vert\mathcal{H}\vert\), that would be too loose!)</em></p> <p><strong>Growth function.</strong> The growth function \(Γ_\mathcal{H}(m)\) of a hypothesis class \(\mathcal{H}\) is given by</p> <p>\begin{equation}\label{eq:growth-function}\Gamma_\mathcal{H}(m)=\sup_{x_1, \dots, x_m\in \mathcal{X}}\vert \mathcal{H}\vert_{(x_1, \dots, x_m)}\vert \end{equation}</p> <p>By definition, \(\vert\mathcal{H}\vert_S\vert \le Γ_\mathcal{H}(m)\) for any \(S_x\) of size \(m\); thus for binary classifiers with zero-one loss, we immediately know that the expected worst-case generalization gap</p> \[\mathbb{E}_{S\sim D^m} \sup_{h\in\mathcal{H}} L_D(h)-L_{S}(h) \le 2 \mathbb{E}_{S\sim D^m} \mathrm{Rad}((\ell_{0,1} \circ \mathcal{H})|_S) \le \sqrt{\frac{2}{m} \log \Gamma_\mathcal{H}(m)}\] <p><strong>Shatter.</strong> A hypothesis class \(\mathcal{H}\) is said to shatter a set \(S_x ⊆ \mathcal{X}\) if it can achieves all possible labellings of \(S_x\), i.e. \(\vert \mathcal{H}\vert_{S_x}\vert = 2^m\).</p> <p><strong>VC dimension.</strong> The VC dimension of \(\mathcal{H}\) is the size of the largest set \(\mathcal{H}\) can shatter:</p> \[\mathrm{VCdim}(\mathcal{H})=\max\{m\ge0: \Gamma_\mathcal{H}(m) = 2^m\}\] <p>If \(\mathcal{H}\) can shatter unboundedly large sets, we say its VC dimension is infinite. We can bound the growth function in terms of the VC dimension: \(\Gamma_\mathcal{H}(m)= \mathcal{O}(m^{\mathrm{VCdim}(\mathcal{H})})\).</p> <p><strong>Compute VC dimension</strong></p> <ul> <li>\(\mathrm{VCdim}(\{x \to \mathbb{1}(x\ge a) :a∈\mathbb{R}\})=1\).</li> <li>\(\mathrm{VCdim}(\{x\to \mathrm{sgn}(w\cdot x) : w\in \mathbb{R}^d\}) = d\).</li> <li>\(\mathrm{VCdim}(\{x\to w\cdot x + b : w\in \mathbb{R}^d, b\in \mathbb{R} \}) = d+1\).</li> </ul> <p><strong>Bound the growth function</strong></p> <ul> <li>\(m \le \mathrm{VCdim}(\mathcal{H})\) case: \(\Gamma_\mathcal{H}(m) = 2^m\)</li> <li>\(m &gt; \mathrm{VCdim}(\mathcal{H})\) case: \(\Gamma_\mathcal{H}(m)\le (\frac{em}{\mathrm{VCdim}(\mathcal{H})})^{\mathrm{VCdim}(\mathcal{H})}\). In this case,</li> </ul> \[\mathbb{E}_{S\sim D^m} \sup_{h\in\mathcal{H}} L_D(h)-L_{S}(h) \le \sqrt{\frac{2\mathrm{VCdim}(\mathcal{H})}{m} (1+\log m-\log \mathrm{VCdim}(\mathcal{H}))}\] <p>When \(\mathrm{VCdim}(\mathcal{H}) ≥ 3\), we can replace \(\log m + 1 − \log \mathrm{VCdim}(\mathcal{H})\) with simply \(\log m\) above.</p> <p><strong>The overall bound on estimation error</strong></p> <p>If \(m &gt; \mathrm{VCdim}(\mathcal{H})\) and we use zero-one loss</p> \[\begin{align*} &amp;\mathrm{Pr}\left(\sup_{h\in\mathcal{H}} [L_D(h) - L_S(h)] &gt; \sqrt{\frac{2\mathrm{VCdim}(\mathcal{H})}{m} (1+\log m-\log \mathrm{VCdim}(\mathcal{H}))} + \sqrt{\frac{1}{2m}\log\frac{1}{\delta}} \right) &lt; \delta \\ &amp;\mathrm{Pr}\left(L_S(h^*) - L_D(h^*) &gt; \sqrt{\frac{1}{2m}\log\frac{1}{\delta}} \right) &lt; \delta \end{align*}\] <p>With probability at least \(1-\delta\), the estimation error satisfy</p> \[\begin{align*} L_D(\hat h_S) - L_D(h^*) &amp;\le \sup_{h\in\mathcal{H}} [L_D(h)-L_S(h)] + L_S(h^*) - L_D(h^*) \\ &amp;\le \sqrt{\frac{2\mathrm{VCdim}(\mathcal{H})}{m} (1+\log m-\log \mathrm{VCdim}(\mathcal{H}))} + \sqrt{\frac{2}{m}\log\frac{2}{\delta}} \end{align*}\] <hr/> <h4 id="lower-bound">Lower bound</h4> <p>if we only know upper bounds, we never really know how tight they are, and so we can never really know if one algorithm is better than another.</p> <p><strong>No free lunch</strong></p> <p>Let \(\mathcal{H}\) be a hypothesis set of binary classifiers over \(\mathcal{X}\). Let \(m ≤ \mathrm{VCdim}(\mathcal{H})/2.\) Then</p> \[\inf_{\mathcal{A}}\sup_{D\ realizable\ by\ \mathcal{H}}\mathrm{Pr}_{S\sim D^m}\left(L_D(\mathcal{A}(S)) \ge \frac18 \right) \ge \frac17\] <p>where the infimum over \(\mathcal{A}\) is over all learning algorithms which return hypotheses in \(\mathcal{H}\). This theorem implies Any \(\mathcal{H}\) with \(\mathrm{VCdim}(\mathcal{H}) = ∞\) is not PAC learnable.</p> <ul> <li>a “no free lunch” theorem, in that there is no algorithm that always works (in the sense of PAC learning): every algorithm fails on at least one distribution.</li> </ul> <p><strong>Lower bound based on VC dimension</strong></p> <p>Let \(\mathcal{H}\) be a hypothesis set of binary classifiers over \(\mathcal{X}\). For any \(m\ge 1\),</p> \[\inf_{\mathcal{A}}\sup_{D\ realizable\ by\ \mathcal{H}}\mathrm{Pr}_{S\sim D^m}\left(L_D(\mathcal{A}(S)) \ge \frac{\mathrm{VCdim}(\mathcal{H})-1}{32m} \right) \ge \frac{1}{100}\] <p>where \(L_D\) uses zero-one loss, and the infimum over \(\mathcal{A}\) is over all learning algorithms returning hypotheses in \(\mathcal{H}\).</p> <hr/> <h1 id="beyond-uniform-convergence">Beyond uniform convergence</h1> <p>if we don’t know what the optimal predictor looks like, we can just try a bunch of different H, which induces the concept of non-uniform bound and structural risk minimization</p> <h2 id="non-uniform-learning">Non-uniform learning</h2> <p>Let \(\mathcal{H}=\mathcal{H}_1\bigcup\mathcal{H}_2\bigcup \cdots\), a set of weights \(w_k ≥ 0\) and \(\sum_{k}w_k \le 1\). Assume that each \(\mathcal{H}_k\) has uniform convergence:</p> \[\mathrm{Pr}_{S\sim D^m}(\sup_{h\in\mathcal{H}_k} \ L_S(h) - L_D(h) \le \varepsilon_k(m, \delta)) \ge 1-\delta\] <p>where for all \(k\) and \(\delta\in(0,1)\), \(\lim_{m\to \infty} \varepsilon_k(m, \delta) =0\).<br/> Then for any \(D\), with probability at least \(1 − δ\) over the choice of \(S ∼ D^m\) , we have</p> \[∀h∈\mathcal{H}. \ L_D(h)≤L_S(h)+ \min_{k:h∈\mathcal{H}_k}\varepsilon_k(m, w_k \delta)\] <details><summary>Proof for non-uniform bound</summary> <p>Given a set of weights \(w_k ≥ 0\) on \(\mathcal{H}_k\), for each \(k\) we have</p> \[\mathrm{Pr}_{S\sim D^m}(\exists h \in\mathcal{H}_k. \ L_S(h) - L_D(h) &gt; \varepsilon_k(m, w_k \delta)) &lt; w_k \delta\] <p>Then,</p> \[\begin{align*}\mathrm{Pr}_{S\sim D^m}\left( \bigcap_k (\forall h \in\mathcal{H}_k. \ L_S(h) - L_D(h)) \le \varepsilon_k(m, w_k \delta)\right) \ge 1 - \sum_k w_k \delta\\ \Rightarrow \mathrm{Pr}_{S\sim D^m}\left(∀h∈\mathcal{H}. \ L_D(h)≤L_S(h)+ \min_{k:h∈\mathcal{H}_k}\varepsilon_k(m, w_k \delta) \right) \ge 1-\delta\end{align*}\] </details> <p><br/></p> <h3 id="structural-risk-minimization-srm">Structural risk minimization (SRM)</h3> <p>SRM is then the algorithm that minimizes this upper bound on \(L_D(h)\)</p> <p><strong>Definition 1.</strong> Let \(\mathcal{H}=\bigcup_{k:w_k&gt;0}\mathcal{H}_k\), a set of weights \(w_k ≥ 0\) and \(\sum_{k}w_k \le 1\). Given the uniform convergence bound on the decomposition of \(\mathcal{H}\), structural risk minimization is given by:</p> \[\mathrm{SRM}_{\mathcal{H}}(S) \in \arg\min_{h\in\mathcal{H}} L_S(h)+ \varepsilon_{k_h}(m, w_{k_h} \delta) \ \text{ where }k_h\in\min_{k:h∈\mathcal{H}_k}ε_k(m,δw_k)\] <p>where \(k: h\in\mathcal{H}_k\) refers to the index of the hypothesis classes where \(h\) lives in (there is at least one \(\mathcal{H}_k\) that contains \(h\)).</p> <p><strong>Definition 2.</strong> Let \(\mathcal{H}=\bigcup_{k:w_k&gt;0}\mathcal{H}_k\), a set of weights \(w_k ≥ 0\) and \(\sum_{k}w_k \le 1\). If we could eliminate the dependence on \(\delta\) of \(\varepsilon\), the structural risk minimization can also be defined by:</p> \[\mathrm{SRM}_{\mathcal{H}}(S) \in \arg\min_{h\in\mathcal{H}} L_S(h)+ \varepsilon_{k_h}(m, w_{k_h}) \ \text{ where }k_h\in\min_{k:h∈\mathcal{H}_k}ε_k(m,w_k)\] <p>This bound don’t need to commit to a certain \(\delta\) during training, so it is better to use in pratice.</p> <p><strong>Estimation error bound of SRM</strong></p> <p>Let \(\hat h_S=\mathrm{SRM}_{\mathcal{H}}(S)\) for simplification and \(h^*\) be any fixed function in \(\mathcal{H}\), we have</p> \[\begin{align*} \mathrm{Pr}\left(L_D(\hat h_S) &gt; L_S(h^*) + \varepsilon_{k_{h^*}}(m, \frac{1}{2} w_{k_{h^*}} \delta) \right) &lt; \mathrm{Pr}\left(L_D(\hat h_S) &gt; L_S(\hat h_S) + \varepsilon_{k_{\hat h_S}}(m, \frac{1}{2} w_{k_{\hat h_S}} \delta) \right) &lt; \frac12\delta \\ \mathrm{Pr}\left(L_S(h^*) - L_D(h^*) &gt; (b-a) \sqrt{\frac{1}{2m}\log\frac{2}{\delta}} \right) &lt; \frac12\delta \end{align*}\] <p>Then, with probability at least \(1-\delta\) over the choice of \(S \sim D^m\), we have</p> \[\begin{align*} L_D(\mathrm{SRM}_{\mathcal{H}}(S)) - L_D(h^*) &amp;\le \varepsilon_{k_{h^*}}(m, \frac{1}{2} w_{k_{h^*}} \delta) + (b-a) \sqrt{\frac{1}{2m}\log\frac{2}{\delta}} \end{align*}\] <details><summary>Example: specific bound using Rademacher complexity</summary> <p>Here we introduce a specific bound using Rademacher complexity. Let the Rademacher complexity of \(k\)th hypothesis \(R_k = \mathbb{E}_{S\sim D^m} \mathrm{Rad} (\mathcal{H}_k\vert_S)\). According to the high probability bounds with Rademacher complexity, for each \(k\), we have</p> \[\begin{align*} \mathrm{Pr}_{S\sim D^m}\left(\sup_{h\in\mathcal{H}_k} \ L_S(h) - L_D(h) \le 2R_k + (b-a)\sqrt{\frac{1}{2m}\log\frac{1}{\delta}} \right) \ge 1-\delta \end{align*}\] <p>Then, let \(k_h=\arg\min_{k:h\in\mathcal{H}_k} 2R_{k_h} + (b-a)\sqrt{\frac{1}{2m}\log\frac{1}{w_{k_h}\delta}}\), we have</p> \[\begin{align*} \mathrm{Pr}_{S\sim D^m}\left(\sup_{h\in\mathcal{H}} \ L_S(h) - L_D(h) \le 2R_{k_h} + (b-a)\sqrt{\frac{1}{2m}\log\frac{1}{w_{k_h}\delta}} \right) \ge 1-\delta \end{align*}\] <p>To separate \(w_k\) and \(\delta\), we can choose \(w_k=\frac{6}{\pi^2k^2}\) such that with probability at least \(1-\delta\)</p> \[\begin{align*} \sup_{h\in\mathcal{H}} \ L_S(h) - L_D(h) &amp;\le 2R_{k_h} + (b-a)\sqrt{\frac{1}{2m}\log\frac{\pi^2{k_h}^2}{6\delta}} \\ &amp;\le 2R_{k_h} + (b-a)\sqrt{\frac{1}{2m}(2\log{k_h} + \log\frac{\pi^2}{6} + \log\frac{1}{\delta})}\\ &amp;\le 2R_{k_h} + (b-a)\sqrt{\frac{1}{2m}(2\log{k_h} + \log\frac{\sqrt{e}}{\delta})}\\ &amp;\le 2R_{k_h} + (b-a)\sqrt{\frac{1}{m}\log{k_h}} + (b-a)\sqrt{\frac{1}{2m}\log\frac{\sqrt{e}}{\delta}} \end{align*}\] <p>Then the SRM solution is given by\(\mathrm{SRM}_{\mathcal{H}}(S) \in \arg\min_{h\in\mathcal{H}} L_S(h)+ 2R_{k_h} + (b-a)\sqrt{\frac{1}{m}\log{k_h}}\)</p> <p>Let \(\hat h_S=\mathrm{SRM}_{\mathcal{H}}(S)\) , then with probability at least \(1-\delta\)</p> \[\begin{align*} L_D(\hat h_S) &amp;\le L_S(\hat h_S) + 2R_{k_{\hat h_S}} + (b-a)\sqrt{\frac{1}{m}\log{k_{\hat h_S}}} + (b-a)\sqrt{\frac{1}{2m}\log\frac{\sqrt{e}}{\delta}}\\ &amp;\le L_S(h^*) + 2R_{k_{h^*}} + (b-a)\sqrt{\frac{1}{m}\log{k_{h^*}}} + (b-a)\sqrt{\frac{1}{2m}\log\frac{\sqrt{e}}{\delta}}\\ &amp;\le L_D(h^*) + 2R_{k_{h^*}} + (b-a)\sqrt{\frac{1}{m}\log{k_{h^*}}} + (b-a)\sqrt{\frac{1}{2m}\log\frac{2\sqrt{e}}{\delta}}+(b-a) \sqrt{\frac{1}{2m}\log\frac{2}{\delta}} \\ &amp;\le L_D(h^*) + 2\mathbb{E}_{S\sim D^m} \mathrm{Rad} (\mathcal{H}_{k_{h^*}}|_S) + (b-a)\sqrt{\frac{1}{m}\log{k_{h^*}}} + (b-a)\sqrt{\frac{2}{m}\log\frac{3}{\delta}}) \end{align*}\] <p>where \(h^*\) is any function in hypothesis \(\mathcal{H}\).</p> </details> <p><br/></p> <hr/> <h2 id="algorithmic-stability">Algorithmic stability</h2> <ul> <li>Sometimes \(\mathcal{H}\) is too big for uniform convergence, but \(\mathcal{A}\) still learns well. Stability based bound is algorithm-specific that it can be insightful for models prone to non-uniform behavior, like deep networks.</li> <li>Stability-based bounds measure how much the model’s performance changes when the training data is slightly perturbed.</li> </ul> <p><strong>Randomness of algorithm</strong></p> <ul> <li>When we’re dealing with specific algorithms, though, it’s important to note that these algorithms might be randomized: for instance, stochastic gradient descent sees points in a random order, and might start at a random location.</li> <li>We’ll always assume that this randomness is independent of \(S\) (other than its size): for instance, this will be the random seed that determines that pattern in which we access the \(z_i\) . If \(\mathcal{A}\) is deterministic, it’s just a point-mass distribution.</li> </ul> <p><strong>Notation.</strong> for changing single sample points in set \(S\) : If \(S = (z_1, \dots, z_{i-1}, z_i, z_{i+1}, \ldots, z_m)\), then \(S^{(i\leftarrow z')}=(z_1, \dots, z_{i-1}, z_i', z_{i+1}, \ldots, z_m)\).</p> <p><strong>Proposition.</strong> For any distribution \(\mathcal{D}\) and learning algorithm \(\mathcal{A}\),</p> \[\mathbb{E}_{S\sim D^m, \mathcal{A}} [L_D(\mathcal{A}(S)) - L_S(\mathcal{A}(S))] = \mathbb{E}_{\substack{S\sim D^m, z_i'\sim D\\ \mathcal{A}, i\sim\text{Unif}([m])}} [\ell(\mathcal{A}(S^{(i\leftarrow z')}), z_i) - \ell(\mathcal{A}(S), z_i)]\] <p><strong>Definition (average stability).</strong> \(\mathcal{A}\) is \(ε(m)\)-on-average-replace-one stable if for all \(D\),</p> \[\mathbb{E}_{\substack{S\sim D^m, z_i'\sim D\\ \mathcal{A}, i\sim\text{Unif}([m])}} [\ell(\mathcal{A}(S^{(i\leftarrow z')}), z_i) - \ell(\mathcal{A}(S), z_i)] \le \varepsilon (m)\] <p>Thus, an \(ε(m)\)-on-average-replace-one stable algorithm will have small average-case generalization gap \(\mathbb{E}_{S\sim D^m, \mathcal{A}} [L_D(\mathcal{A}(S)) - L_S(\mathcal{A}(S))]\).</p> <p><strong>Definition (uniform stability).</strong> \(\mathcal{A}\) is \(β(m)\)-uniformly stable if for all \(m ≥ 1\) and all \(i\in\{1,\dots,m\}\)</p> \[\sup_{\substack{S\sim D^m \\ z, z'\sim D}} [\mathbb{E}_{\mathcal{A}} \ell(\mathcal{A}(S^{(i\leftarrow z')}), z) - \mathbb{E}_{\mathcal{A}}\ell(\mathcal{A}(S), z)] \le \beta (m)\] <p>That is, changing one point in any training set gives you a hypothesis that looks almost the same for any test point.</p> <p><strong>Upper bound \(\mathbb{E}_{\mathcal{A}} [L_D(\mathcal{A} (S))- L_S(\mathcal{A} (S))]\)</strong></p> <p><strong>Theorem (uniform-stability).</strong> Suppose that \(\ell(h, z) ∈ [a, b]\) almost surely. Let \(\mathcal{A}\) be \(β(m)\)-uniformly stable. Then, with probability at least \(1 − δ\) over the choice of training points \(S ∼ D^m\),</p> \[\mathbb{E}_{\mathcal{A}} [L_D(\mathcal{A} (S))- L_S(\mathcal{A} (S))] \le \beta(m)+(2m\beta(m)+b-a) \sqrt{\frac{1}{2m} \log\frac{1}{\delta}}\] <p>The best case for this bound is when \(β(m) = \mathcal{O}(1/m)\), in which case you get a \(\mathcal{O}(1/\sqrt{m})\) rate.</p> <details><summary>Proof for the theorem</summary> <p>Let \(f(S)=\mathbb{E}_{\mathcal{A}} [L_D(\mathcal{A} (S))- L_S(\mathcal{A} (S))]\). If \(\mathcal{A}\) is \(\beta(m)\)-uniformly stable, then \(\mathbb{E}_S f(S)\le \beta(m)\). Assume \(\ell \in [a,b]\), let \(\hat h = \mathcal{A}(S), \hat h^i=\mathcal{A}(S^{(i \leftarrow z')})\).</p> <p>We have</p> \[\begin{align*} \vert \mathbb{E}_{\mathcal{A}} [L_D(\hat h^i)- L_D(\hat h)] \vert &amp;= \vert \mathbb{E}_{\mathcal{A}, z\sim D} \ell(\hat h^i, z) - \mathbb{E}_{\mathcal{A}}\ell(\hat h, z) \vert \\ &amp;\le \mathbb{E}_{z\sim D}\vert \mathbb{E}_{\mathcal{A}} \ell(\hat h^i, z) - \mathbb{E}_{\mathcal{A}}\ell(\hat h, z) \vert \\ &amp;\le \beta(m)\\ \end{align*}\] <p>Also, we have</p> \[\begin{align*} \vert\mathbb{E}_{\mathcal{A}} [L_S(\hat h)- L_{S^{(i\leftarrow z')}}(\hat h^i)]\vert &amp;= \frac{1}{m} \left\vert \mathbb{E}_{\mathcal{A}}\sum_{j=1}^m (\ell(\hat h, z_j) - \ell(\hat h^i, z_j))\right\vert\\ &amp;\le \frac{1}{m} \sum_{j\neq i} \left\vert \mathbb{E}_{\mathcal{A}} \ell(\hat h, z_j) - \ell(\hat h^i, z_j) \right\vert + \frac{1}{m} \left\vert \mathbb{E}_{\mathcal{A}} \ell(\hat h, z_i) - \ell(\hat h^i, z_i) \right\vert \\ &amp;\le \frac{m-1}{m} \beta(m) + \frac{b-a}{m} \\ &amp;\le \beta(m) + \frac{b-a}{m} \end{align*}\] <p>Combining the above two inequalities, we can show the bounded difference of \(f(S)\) that</p> \[\begin{align*}\vert f(S) - f(S^{(i \leftarrow z')})\vert &amp;= \left\vert\mathbb{E}_{\mathcal{A}} [L_D(\hat h)- L_S(\hat h) - L_D(\hat h^i) +L_{S^{(i \leftarrow z')}}(\hat h^i)] \right\vert \\ &amp;\le \left\vert\mathbb{E}_{\mathcal{A}} [L_D(\hat h)- L_D(\hat h^i)] \right\vert + \left\vert \mathbb{E}_{\mathcal{A}}[ L_S(\hat h) - L_{S^{(i \leftarrow z')}}(\hat h^i)]\right\vert \\ &amp;\le 2\beta(m) + \frac{b-a}{m} \end{align*}\] <p>According to <a href="https://en.wikipedia.org/wiki/McDiarmid%27s_inequality">McDiarmid’s inequality</a>, with probability at least \(1-\delta\)</p> \[\begin{align*} \mathbb{E}_{\mathcal{A}} [L_D(\mathcal{A} (S))- L_S(\mathcal{A} (S))] &amp;\le \mathbb{E}_{S} \mathbb{E}_{\mathcal{A}} [L_D(\mathcal{A} (S))- L_S(\mathcal{A} (S))] + \sqrt{\frac12 m(2\beta(m) + \frac{b-a}{m})^2 \log \frac{1}{\delta}}\\ &amp;\le \beta(m) + (2m\beta(m) + b-a)\sqrt{\frac{1}{2m} \log \frac{1}{\delta}} \end{align*}\] </details> <p><br/></p> <h3 id="regularized-loss-minimization">Regularized loss minimization</h3> <p>Major challenges for using ERM to explain deep learning:</p> <ul> <li><strong>Computational Hurdle:</strong> ERM minimizes the empirical loss over the training data. However, for complex deep learning models with millions of parameters, this optimization problem becomes computationally NP-hard.</li> <li><strong>Intractability of Uniform Convergence:</strong> Uniform convergence ERM bounds might not be enough for generalization. In practice, deep learning models often exhibit non-uniform convergence, where their performance can vary significantly across different data points.</li> <li><strong>Regularized Loss Minimization (RLM):</strong> In reality, we often observe that regularized loss minimization (RLM), which optimizes a trade-off between model complexity and loss, leads to better generalization performance even if it doesn’t strictly minimize the empirical risk.</li> </ul> <p>Therefore, while ERM remains a theoretical cornerstone for understanding generalization, regularized loss minimization emerges as the preferred approach in practice. By incorporating regularization terms that penalize model complexity, we can achieve better generalization performance and obtain more interpretable models.</p> <p>Regularized loss minimization (RLM) adds a regularization term (or regularizer) to a loss function:</p> \[\arg\min_{h\in \mathcal{H}} L_S(h) + λR(h)\] <p>It is closely connected to constrained ERM:</p> \[\arg\min_{h\in \mathcal{H}: R(h) \le B} L_S(h)\] <p>they are Lagrange dual to each other: for any λ, there is some B such that the solutions agree, and vice versa.</p> <p>But RLM is typically easier computationally, and it’s usually easier to choose a good λ than to choose a good B.</p> <p>Suppose the loss function \(h → \ell(h, z)\) is convex for each \(z\), and regularizer \(R(h)\) is 1-strongly convex. Then \(f_S(h) = L_S(h) + λR(h)\), the sum of a convex function and a λ-strongly convex function, is λ-strongly convex. Let \(\mathcal{A}(S)\) denote \(\arg\min_{h\in \mathcal{H}} f_S(h)\); since \(f_S\) is strongly convex, it has a unique minimizer (so we can leave out the \(\mathbb{E}_\mathcal{A}\) term).</p> <p><strong>Upper bound \(L_D (\mathcal{A}(S))-L_D(h^*)\)</strong></p> <p>Assume the regularizer is \(R(h)\) is nonnegative, and \(R(h^*) \le \frac12 B^2\) for any \(h^*\). If \(L_S(h)\) is convex, \(R(h)\) is 1-strongly convex and \(l(h,z)\) is \(\rho\)-Lipschitz, we have</p> \[\mathbb{E}_S L_D(\mathcal{A}(S)) \le L_D(h^*)+ \frac12 \lambda B^2+ \frac{4\rho^2}{\lambda m}\] <p>For any fixed \(h^*\), it holds with probability at least \(1 − \delta\) that</p> \[L_D (\mathcal{A}(S)) \le L_D(h^*) + \frac \lambda 2 B^2 + \frac{4\rho^2}{\lambda m} + \frac{4\rho^2}{\lambda m} \sqrt{\frac m 2 \log \frac1 \delta}\] <p><code class="language-plaintext highlighter-rouge">Proof sketch.</code></p> <ul> <li>Given the convex and Lipschitz assumption, we can show RLM is \(\frac{4\rho^2}{\lambda m}\)-uniformly stable</li> <li>then bound \(\mathbb{E}_S L_D(\mathcal{A}(S)) - L_S(\mathcal{A}(S))\) using uniformly stability</li> <li>also, \(L_S(\mathcal{A}(S)) \le L_S(h^*)+R(h)\)</li> <li>Then \(\mathbb{E}_S L_D(\mathcal{A}(S)) \le L_D(h^*)+ \frac12 \lambda B^2+ \frac{4\rho^2}{\lambda m}\)</li> <li>Use McDiarmid’s inequality to derive the high probability bound\(L_D (\mathcal{A}(S)) \le \mathbb{E}_S L_D(\mathcal{A}(S)) + \frac{4\rho^2}{\lambda m} \sqrt{\frac m 2 \log \frac1 \delta}\)</li> </ul> <details><summary>Full proof</summary> <p>We first show that the function \(f_S(h)=L_S(h) + λR(h)\) is \(\frac{4\rho^2}{\lambda m}\)-uniformly stable if \(L_S(h)\) is convex, \(R(h)\) is 1-strongly convex and \(l(h,z)\) is \(\rho\)-Lipschitz. Let \(S'=S^{(i \leftarrow z')}\), then</p> \[\begin{align*} f_S(h)-f_S(g)&amp;=f_S(h)-f_{S'}(h)+f_{S'}(h) - f_{S'}(g)+f_{S'}(g)-f_{S}(g)\\ &amp;=f_{S'}(h) - f_{S'}(g)+ \frac{1}{m} (\ell (h,z_i) - \ell(h, z_i')) + \frac{1}{m} (\ell (g,z_i') - \ell(g, z_i))\\ &amp;=f_{S'}(h) - f_{S'}(g)+ \frac{1}{m} (\ell (h,z_i) - \ell(g, z_i)) + \frac{1}{m} (\ell (g,z_i') - \ell(h, z_i')) \end{align*}\] <p>Let \(\hat h = \arg\min_h f_S(h)\) and \(\hat h^i = \arg\min_h f_S'(h)\). Then,</p> \[\begin{align*} f_S(\hat h^i) - f_S(\hat h) &amp;\le \frac{1}{m} (\ell (\hat h^i,z_i) - \ell(\hat h, z_i)) + \frac{1}{m} (\ell (\hat h,z_i') - \ell(\hat h^i, z_i')) \end{align*}\] <p>As \(f_S(h)\) is \(\lambda\)-strongly convex and \(\nabla f_S(\hat h)=0\), then</p> \[f_S(\hat h^i) - f_S(\hat h) \ge \langle \nabla f_S(\hat h), \hat h^i-\hat h \rangle +\frac12 \lambda \Vert \hat h^i-\hat h\Vert^2 = \frac12 \lambda \Vert\hat h^i-\hat h\Vert^2\] <p>Thus,</p> \[\begin{align*} \frac12 \lambda \Vert \hat h^i-\hat h\Vert ^2 &amp;\le \frac{1}{m} (\ell (\hat h^i,z_i) - \ell(\hat h, z_i)) + \frac{1}{m} (\ell (\hat h,z_i') - \ell(\hat h^i, z_i'))\le \frac{2\rho}{m} \Vert \hat h^i-\hat h\Vert \\ &amp;\Rightarrow \Vert \hat h^i-\hat h\Vert \le \frac{4\rho}{\lambda m} \\ &amp;\Rightarrow \vert\ell (\hat h,z_i') - \ell(\hat h^i, z_i')\vert \le \frac{4\rho^2}{\lambda m} \end{align*}\] <p>\(\mathcal{A}\) is \(\frac{4\rho^2}{\lambda m}\)-uniformly stable.</p> <p>Assume \(R(h)\) is non-negative, then</p> \[L_S(\mathcal{A}(S)) \le L_S(\mathcal{A}(S))+\lambda R(\mathcal{A}(S)) \le L_S(h^*)+\lambda R(h^*)\] <p>for all \(h^* \in \mathcal{H}\). Then \(\mathbb{E}_S L_S(\mathcal{A}(S)) \le L_D(h^*)+\lambda R(h^*)\).</p> \[\mathbb{E}_S L_D (\mathcal{A}(S)) \le \mathbb{E}_S L_S(\mathcal{A}(S)) + \frac{4\rho^2}{\lambda m}\le L_D(h^*) + \frac \lambda 2 B^2 + \frac{4\rho^2}{\lambda m}\] <p>where we don’t actually need to apply uniform-stability theorem directly.</p> </details> <p><br/></p>]]></content><author><name></name></author><category term="basics"/><category term="learning-theory"/><category term="note"/><summary type="html"><![CDATA[a short overview on techniques to prove learning bounds]]></summary></entry><entry><title type="html">a lecture note on modern statistical learning theory</title><link href="https://he-zh.github.io/blog/2023/cpsc532d-note/" rel="alternate" type="text/html" title="a lecture note on modern statistical learning theory"/><published>2023-10-20T00:00:00+00:00</published><updated>2023-10-20T00:00:00+00:00</updated><id>https://he-zh.github.io/blog/2023/cpsc532d-note</id><content type="html" xml:base="https://he-zh.github.io/blog/2023/cpsc532d-note/"><![CDATA[<p>Hand-written notes taken on <a href="https://www.cs.ubc.ca/~dsuth/532D/23w1/">CPSC 532D Statistical Learning Theory</a>.</p> <object data="/assets/pdf/Statistical_learning_theory.pdf" width="100%" height="500px"> <p>Unable to display PDF file. <a href="/assets/pdf/Statistical_learning_theory.pdf">Download</a> instead.</p> </object>]]></content><author><name></name></author><category term="basics"/><category term="learning-theory"/><category term="note"/><summary type="html"><![CDATA[hand-written notes of key concepts and proofs for cpsc 532d]]></summary></entry><entry><title type="html">learning with biased labels</title><link href="https://he-zh.github.io/blog/2023/biased-label/" rel="alternate" type="text/html" title="learning with biased labels"/><published>2023-02-01T00:00:00+00:00</published><updated>2023-02-01T00:00:00+00:00</updated><id>https://he-zh.github.io/blog/2023/biased-label</id><content type="html" xml:base="https://he-zh.github.io/blog/2023/biased-label/"><![CDATA[<p>Deep Neural Networks (DNNs) have gained popularity in a wide range of applications. The remarkable success of DNNs often relies on the availability of high-quality datasets. However, the acquisition of a large amount of well-annotated unambiguous data could be very expensive and sometimes even inaccessibl. Standard training using ambiguous data may produce overly confident models and thus leading to poor generalization.</p> <p>During my stay at Baidu Research, I have been have been actively engaged in the realm of learning with biased labels, with a specific focus on enhancing model robustness and reliability in the presence of noisy data. This presentation serves as a comprehensive overview of my work. It encompasses the following key components:</p> <ul> <li>A concise review of various methodologies for learning with noisy labels;</li> <li>A specific topic we brought up – addressing the challenge of training data with highly ambiguous labels, such as those that provide an incomplete description of the object. (This part is temporarily deleted from this post.)</li> </ul> <p>I believe that our research may shed some light on how to build a more trustworthy machine learning model, especially in domains where data quality is a critical factor.</p> <object data="/assets/pdf/learning_with_biased_labels_hez.pdf" width="100%" height="500px"> <p>Unable to display PDF file. <a href="/assets/pdf/learning_with_biased_labels_hez.pdf">Download</a> instead.</p> </object>]]></content><author><name></name></author><category term="research"/><category term="survey"/><category term="paper-digest"/><category term="slide"/><category term="label-noise"/><summary type="html"><![CDATA[a review on robust learning with noisy labels]]></summary></entry><entry><title type="html">sparse double descent where network pruning aggravates overfitting</title><link href="https://he-zh.github.io/blog/2022/sparsedd/" rel="alternate" type="text/html" title="sparse double descent where network pruning aggravates overfitting"/><published>2022-07-12T00:00:00+00:00</published><updated>2022-07-12T00:00:00+00:00</updated><id>https://he-zh.github.io/blog/2022/sparsedd</id><content type="html" xml:base="https://he-zh.github.io/blog/2022/sparsedd/"><![CDATA[<p>Here I share our new work on network pruning “Sparse Double Descent: Where Network Pruning Aggravates Overfitting”. This work was mainly inspired by recent studies on model over-parameterization and lottery tickets hypothesis, where we explored and analyzed the generalization performance of sparse neural networks. Main conclusion: The double descent phenomenon exists in sparse neural networks-as sparsity increases, the test accuracy of the model will first decrease, then increase, and finally decrease again.</p> <h2 id="motivation">Motivation</h2> <p>Machine learning models are widely believed to have difficulty minimizing both bias and variance at once. Thus finding the most appropriate model requires balancing these two factors. Here shows the traditional bias-variance tradeoff curve: as model capacity increases, the training error decreases, while the test error first decreases and then increases.</p> <div class="row justify-content-center mt-3"> <div class="col-sm-6 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/sparsedd/u-curve-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/sparsedd/u-curve-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/sparsedd/u-curve-1400.webp"/> <img src="/assets/img/blog/sparsedd/u-curve.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Bias-variance tradeoff. </div> <p>However, in deep learning practice, large models often perform better than smaller models, despite traditional belief that too many parameters leads to overfitting. Studies have found that the relationship between test error and model capacity is not a U-shaped tradeoff, but rather a double descent curve, that is, as the number of model parameters increases, the test error first decreases, then increases, and then decreases again <d-cite key="belkin2019reconciling"></d-cite> <d-cite key="NakkiranKBYBS20"></d-cite>.</p> <div class="row justify-content-center mt-3"> <div class="col-sm-8 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/sparsedd/doubledescent-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/sparsedd/doubledescent-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/sparsedd/doubledescent-1400.webp"/> <img src="/assets/img/blog/sparsedd/doubledescent.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Double descenr curve <d-cite key="NakkiranKBYBS20"></d-cite>. </div> <p>That is to say, an over-parameterized neural network, instead of severely overfitting, may have better generalization performance! This contradicts the traditional belief directly.</p> <p>The lottery tickets hypothesis <d-cite key="FrankleC19"></d-cite> provides a new way for explaining this phenomenon. According to the lottery ticket hypothesis, a randomly initialized dense network contains a well-performing sub-network that can achieve comparable accuracy to the original dense network when trained from the original initialization (winning ticket). More parameters in a network mean a higher chance of containing a sub-network with good performance, and thus a higher chance of winning the lottery.</p> <p>From this point of view, in an over-parameterized neural network, only a relatively small number of parameters play a role in optimization and generalization, while the remaining parameters only serve as redundant backups. The performance of models won’t be greatly affected when redundant parameters were pruned.</p> <p>It appears that we can safely prune redundant parameters from our models without worrying about adverse effects. Moreover, pruned neural networks are believed to have better generalization properties according to Occam’s razor principle <d-cite key="HoeflerABDP21"></d-cite>. The current pruning literature also emphasizes that their algorithm can maintain an accuracy comparable to the original model even when a significant number of parameters are pruned.</p> <p>In light of the double descent phenomenon, we wonder: Are the parameters removed by pruning completely redundant?</p> <p>We investigate this question following the deep double descent setting <d-cite key="NakkiranKBYBS20"></d-cite> and conduct extensive experiments on sparse neural networks.</p> <h2 id="sparse-double-descent">Sparse double descent</h2> <p>Experiments revealed that the “redundant” parameters in the network are not completely redundant. When increasing model sparsity through iterative pruning, even if the model training accuracy has not been affected, its test accuracy may decline significantly, where the model overfits noise. If the sparsity of the model is further increased, it can be found that after passing the <a href="https://www.lesswrong.com/posts/FRv7ryoqtvSuqBxuT/understanding-deep-double-descent">interpolation threshold</a>, the training accuracy of the model begins to drop rapidly, and the test accuracy begins to increase, and the robustness of the model to noise is gradually improved. If you continue to reduce the parameters of the model after the test accuracy rate reaches its highest point, the training and testing accuracy of the model decreases at the same time, where the model gradually loses its learning ability. ​</p> <div class="row justify-content-center mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/sparsedd/dataset-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/sparsedd/dataset-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/sparsedd/dataset-1400.webp"/> <img src="/assets/img/blog/sparsedd/dataset.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Sparse double descent on different datasets. Left: CIAFR-10. Middle: CIFAR-100. Right: Tiny ImageNet. </div> <p>In addition, we also found that using different criteria for pruning, the resulting models have different model capacity/complexity even with the same amount of parameters. For example, for the interpolating threshold, the model pruned using magnitude-based method has higher sparsity, while the model pruned with random pruning corresponds to lower sparsity. It shows that random pruning damages the representative capability of the model more severely, and fewer parameters can be pruned to achieve the same effect.</p> <div class="row justify-content-center mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/sparsedd/pruning-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/sparsedd/pruning-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/sparsedd/pruning-1400.webp"/> <img src="/assets/img/blog/sparsedd/pruning.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Sparse double descent with different pruning methods. Left: magnitude based pruning. Middle: gradient based pruning. Right: random pruning. </div> <p>While most of our experiments retrained the lottery ticket hypothesis, several other different approaches were also applied. Interestingly, a significant double drop can be observed even with finetuning after pruning. It can be seen that the phenomenon of sparse double descent is not limited to training a sparse network from initialization. ​</p> <div class="row justify-content-center mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/sparsedd/retrain-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/sparsedd/retrain-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/sparsedd/retrain-1400.webp"/> <img src="/assets/img/blog/sparsedd/retrain.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Sparse double descent with different retraining methods. Left: finetuning. Middle: learning rate rewinding. Right: scratch retraining. </div> <p>We also adjusted the label noise ratio in our experiments. Similar to the deep double descent, increasing the label noise ratio will make the starting point of the model training accuracy drop to move towards a higher model capacity (ie, lower sparsity). On the other hand, the higher label noise ratio, the more parameters need to be pruned to avoid overfitting. ​</p> <div class="row justify-content-center mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/sparsedd/noise-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/sparsedd/noise-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/sparsedd/noise-1400.webp"/> <img src="/assets/img/blog/sparsedd/noise.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Sparse double descent under different label noise ratio. Left: 20%. Middle: 40%. Right: 80%. </div> <h2 id="why-sparse-double-descent-happens">Why sparse double descent happens？</h2> <p>Here we mainly investigate two possible explanations.</p> <p>One is the Minima Flatness Hypothesis. Some papers point out that pruning can add perturbations to the model, which make it easier for the model to converge to a flat minimum <d-cite key="BartoldsonMBE20"></d-cite>. Since flatter minima generally have better generalization ability, so <d-cite key="BartoldsonMBE20"></d-cite> believes that pruning affects the generalization of the model by affecting the minima flatness.</p> <p>So, can minima flatness explain the sparse double descent?</p> <p>We visualized the loss as shown in the figure, and indirectly compared the flatness of the minima of the model under different sparsity.</p> <div class="row justify-content-center mt-3"> <div class="col-sm-6 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/sparsedd/sharpness-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/sparsedd/sharpness-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/sparsedd/sharpness-1400.webp"/> <img src="/assets/img/blog/sparsedd/sharpness.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Loss visualization. </div> <p>Unfortunately, as sparsity increases, the loss curve becomes sharper. There is no evident correlation between the minima flatness and the test accuracy.</p> <p>The other is the Learning Distance Hypothesis.</p> <p>It has been proved theoretically that the complexity of deep learning models is closely related to the l2 distance of the parameters from the initialization (learning distance) <d-cite key="Nagarajan19"></d-cite>. When the model is obtained through early stopping, the model is close to the initialization and there is not enough complexity to memorize noise. And the overly trained model has higher complexity and is easy to overfit.</p> <p>So, may changes in learning distance reflect the trend of double decline? ​</p> <div class="row justify-content-center mt-3"> <div class="col-sm-6 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/sparsedd/distance-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/sparsedd/distance-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/sparsedd/distance-1400.webp"/> <img src="/assets/img/blog/sparsedd/distance.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> The curve of learning distance and test accuracy. </div> <p>As can be seen from the figure, when the accuracy rate decreases, the overall learning distance tends to increase, and the highest point corresponds to the lowest point of the accuracy rate; when the accuracy rate increases, the learning distance also decreases accordingly. The change in learning distance is generally in line with the trend of sparse double descent (although when the test accuracy declines for the second time, it is difficult for the learning distance to rise again due to too few trainable parameters).</p> <h2 id="relation-to-the-lottery-ticket-hypothesis">Relation to the lottery ticket hypothesis</h2> <p>We also conduct experiments comparing winning tickets with re-random initialization. Interestingly, the initialization of the lottery ticket hypothesis does not always outperform the re-initialization of the network in the double-descent scenario. ​</p> <div class="row justify-content-center mt-3"> <div class="col-sm-6 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blog/sparsedd/reinit-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blog/sparsedd/reinit-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blog/sparsedd/reinit-1400.webp"/> <img src="/assets/img/blog/sparsedd/reinit.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Train and test accuracy of lottery ticket initialization and random reinitialization. </div> <p>It can be seen from the figure that the result of Reinit is shifted to the left compared to Lottery as a whole, that is to say, the Reinit method is inferior to Lottery in terms of retaining the expressive ability of the model. This also validates the lottery ticket hypothesis: even if the structure of the model is the same, the performance of the model may be very different when trained from different initializations.</p> <h2 id="conclusion">Conclusion</h2> <p>In the process of doing this research, we observed some amazing and counterintuitive experimental phenomena and attempted to interpret them analytically. However, the existing theoretical work has not been able to fully explain the reasons for the existence of these phenomena.</p> <p>For example, when the training accuracy is close to 100%, the test accuracy will gradually decrease with pruning. Why does the model not forget the complex features in the data at this time, but overfit the noise more seriously? We also observed that the learning distance of the model will increase first and then decrease with the increase of sparsity. Why does pruning cause such a change in the learning distance of the model? And the double descent phenomenon of deep learning models often needs to add label noise to the input to be observed <d-cite key="NakkiranKBYBS20"></d-cite>, what is the mechanism behind whether double descent occurs?</p> <p>There are still many questions that remain unanswered. We are also now working on a new theoretical work that will shed light on one or more of these issues. I hope that the fog can be cleared as soon as possible to find out the essential reasons behind this phenomenon.</p> <p>Paper： <a href="https:​//arxiv.org/abs/2206.08684">Sparse Double Descent: Where Network Pruning Aggravates Overfitting</a></p> <p>Code： <a href="https://github.com/he-zh/sparse-double-descent">​github.com/he-zh/sparse-double-descent</a></p>]]></content><author><name>Zheng HE</name></author><category term="research"/><category term="paper-digest"/><category term="sparse"/><category term="overparameterization"/><summary type="html"><![CDATA[a brief introduction for the ICML paper of sparse double descent]]></summary></entry><entry><title type="html">overparameterization and sparsity</title><link href="https://he-zh.github.io/blog/2021/overparametrization-sparsity/" rel="alternate" type="text/html" title="overparameterization and sparsity"/><published>2021-08-30T00:00:00+00:00</published><updated>2021-08-30T00:00:00+00:00</updated><id>https://he-zh.github.io/blog/2021/overparametrization-sparsity</id><content type="html" xml:base="https://he-zh.github.io/blog/2021/overparametrization-sparsity/"><![CDATA[<p>It is a mystery how overparameterized models behave and why. It is especially intriguing why overparameterized models can generalize well despite the excessive capacity, and why highly sparse neural networks can still achieve comparable performance to the dense networks (as suggested in the <a href="https://arxiv.org/abs/1803.03635">lottery ticket hypothesis</a>).</p> <p>Over the past few months, I have been intrigued by the possible relationship between model generalization and sparsity. The slide below shows a brief review of several related works and the questions that I cared about. Luckily I am able to answer a few of them with my own research now (see <a href="https://he-zh.github.io/_posts/2022-07-Sparse_double_descent/">sparse double descent</a>).</p> <object data="/assets/pdf/ZhengHe_overparametrized_neural_networks.pdf" width="100%" height="500px"> <p>Unable to display PDF file. <a href="/assets/pdf/ZhengHe_overparametrized_neural_networks.pdf">Download</a> instead.</p> </object>]]></content><author><name></name></author><category term="research"/><category term="survey"/><category term="paper-digest"/><category term="slide"/><category term="sparse"/><category term="overparameterization"/><summary type="html"><![CDATA[a review on recent paper about overparameterization and sparsity]]></summary></entry></feed>